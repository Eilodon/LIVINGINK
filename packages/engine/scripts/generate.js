// packages/engine/scripts/generate.js
/**
 * EIDOLON-V GENESIS - Code Generator
 * Generates TypeScript code from schema definition.
 * 
 * Usage: node packages/engine/scripts/generate.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { SCHEMA } from './schema.config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_DIR = path.join(__dirname, '../src/generated');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR, { recursive: true });

// Type Mapping Configuration
const TYPE_MAP = {
    'f32': { array: 'Float32Array', bytes: 4, view: 'getFloat32', set: 'setFloat32' },
    'u32': { array: 'Uint32Array', bytes: 4, view: 'getUint32', set: 'setUint32' },
    'i32': { array: 'Int32Array', bytes: 4, view: 'getInt32', set: 'setInt32' },
    'u16': { array: 'Uint16Array', bytes: 2, view: 'getUint16', set: 'setUint16' },
    'u8': { array: 'Uint8Array', bytes: 1, view: 'getUint8', set: 'setUint8' },
};

function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

function generate() {
    console.log('âš¡ Eidolon-V Genesis: Generating Core Engine...');

    const timestamp = new Date().toISOString();

    // =========================================================================
    // 1. GATHER COMPONENT METADATA FIRST
    // =========================================================================
    const componentMeta = [];

    // Initialize code buffers
    let accessorCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

// Entity State Flags
export const enum EntityFlags {
    ACTIVE = 0x01,
    DEAD = 0x02,
    PLAYER = 0x04,
    BOT = 0x08,
    FOOD = 0x10,
    PROJECTILE = 0x20,
    BOSS = 0x40,
    LOCAL = 0x80,
}

// =============================================================================
// STATE ACCESSOR (Special - uses Uint8Array directly)
// =============================================================================

export class StateAccess {
    static isActive(world: WorldState, id: number): boolean {
        return (world.stateFlags[id] & EntityFlags.ACTIVE) !== 0;
    }

    static isDead(world: WorldState, id: number): boolean {
        return (world.stateFlags[id] & EntityFlags.DEAD) !== 0;
    }

    static setFlag(world: WorldState, id: number, flag: number): void {
        world.stateFlags[id] |= flag;
    }

    static clearFlag(world: WorldState, id: number, flag: number): void {
        world.stateFlags[id] &= ~flag;
    }

    static hasFlag(world: WorldState, id: number, flag: number): boolean {
        return (world.stateFlags[id] & flag) !== 0;
    }

    static getFlags(world: WorldState, id: number): number {
        return world.stateFlags[id];
    }

    static setFlags(world: WorldState, id: number, flags: number): void {
        world.stateFlags[id] = flags;
    }

    static activate(world: WorldState, id: number): void {
        // Only add if not already active (idempotent)
        if ((world.stateFlags[id] & EntityFlags.ACTIVE) === 0) {
            world.stateFlags[id] |= EntityFlags.ACTIVE;
            // EIDOLON-V: Add to Sparse Set
            const idx = world.activeCount++;
            world.activeEntities[idx] = id;
            world.entityToIndex[id] = idx;
        }
    }

    static deactivate(world: WorldState, id: number): void {
        // Only remove if currently active (idempotent)
        if ((world.stateFlags[id] & EntityFlags.ACTIVE) !== 0) {
            world.stateFlags[id] &= ~EntityFlags.ACTIVE;
            // EIDOLON-V: Remove from Sparse Set (swap-remove for O(1))
            const idx = world.entityToIndex[id];
            if (idx >= 0 && idx < world.activeCount) {
                const lastIdx = --world.activeCount;
                const lastId = world.activeEntities[lastIdx];
                world.activeEntities[idx] = lastId;
                world.entityToIndex[lastId] = idx;
                world.entityToIndex[id] = -1;
            }
        }
    }

    static markDead(world: WorldState, id: number): void {
        world.stateFlags[id] |= EntityFlags.DEAD;
    }
}

`;

    let packerCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Network Serialization - Packet matches Memory Layout exactly
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

export const COMPONENT_IDS = {
`;

    let packerBody = `
export class NetworkSerializer {
    /**
     * Pack a single entity's component into a DataView
     * @returns New offset after writing
     */
    static packEntityComponent(
        world: WorldState, 
        id: number, 
        componentId: number, 
        view: DataView, 
        offset: number
    ): number {
        // EIDOLON-V P1: Defense-in-depth bounds check
        if (id < 0 || id >= world.maxEntities) return offset;
        
        switch (componentId) {
`;

    let unpackerBody = '';
    let deserializerCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

export class NetworkDeserializer {
    /**
     * Deserialize a single entity's component from a DataView
     * @returns New offset after reading
     */
    static deserializeComponent(
        world: WorldState, 
        id: number, 
        componentId: number, 
        view: DataView, 
        offset: number
    ): number {
        // EIDOLON-V P1: Defense-in-depth bounds check
        if (id < 0 || id >= world.maxEntities) return offset;
        
        switch (componentId) {
`;

    // Loop Schema
    for (const [compName, config] of Object.entries(SCHEMA)) {
        // Calculate Stride and Offsets
        let stride = 0;
        const fields = [];

        for (const [fieldName, fieldConfig] of Object.entries(config.fields)) {
            const typeInfo = TYPE_MAP[fieldConfig.type];
            if (!typeInfo) {
                console.error(`Unknown type: ${fieldConfig.type} in ${compName}.${fieldName}`);
                continue;
            }
            fields.push({
                name: fieldName,
                type: fieldConfig.type,
                offset: stride,
                bytes: typeInfo.bytes,
                typeInfo: typeInfo,
                default: fieldConfig.default
            });
            stride += typeInfo.bytes;
        }

        // Align stride to 4 bytes for WASM/SIMD compatibility
        if (stride % 4 !== 0) stride += (4 - (stride % 4));

        componentMeta.push({ name: compName, id: config.id, stride, fields });
        const lowerName = compName.toLowerCase();

        // --- Build Accessor ---
        accessorCode += `// =============================================================================
// ${compName.toUpperCase()} ACCESSOR
// =============================================================================

export class ${compName}Access {
    static readonly STRIDE = ${stride};
    static readonly COMPONENT_ID = ${config.id};
    
    // Field Offsets (bytes)
${fields.map(f => `    static readonly ${f.name.toUpperCase()} = ${f.offset};`).join('\n')}

    /**
     * Set all fields at once (optimized)
     */
    static set(world: WorldState, id: number, ${fields.filter(f => !f.name.startsWith('_')).map(f => `${f.name}: number`).join(', ')}): void {
        const view = world.${lowerName}View;
        const ptr = id * ${stride};
${fields.filter(f => !f.name.startsWith('_')).map(f => {
            const le = f.bytes === 1 ? '' : ', true';
            return `        view.${f.typeInfo.set}(ptr + ${f.offset}, ${f.name}${le});`;
        }).join('\n')}
    }
    
    // Individual Getters
${fields.filter(f => !f.name.startsWith('_')).map(f => {
            const le = f.bytes === 1 ? '' : ', true';
            return `    static get${capitalize(f.name)}(world: WorldState, id: number): number {
        return world.${lowerName}View.${f.typeInfo.view}(id * ${stride} + ${f.offset}${le});
    }`;
        }).join('\n\n')}

    // Individual Setters
${fields.filter(f => !f.name.startsWith('_')).map(f => {
            const le = f.bytes === 1 ? '' : ', true';
            return `    static set${capitalize(f.name)}(world: WorldState, id: number, value: number): void {
        world.${lowerName}View.${f.typeInfo.set}(id * ${stride} + ${f.offset}, value${le});
    }`;
        }).join('\n\n')}
}

`;

        // --- Build Packer ---
        packerCode += `    ${compName.toUpperCase()}: ${config.id},\n`;

        packerBody += `            case ${config.id}: { // ${compName}\n`;
        packerBody += `                // Bounds check: need ${stride} bytes to write\n`;
        packerBody += `                if (view.byteLength < offset + ${stride}) return offset;\n`;
        packerBody += `                const srcView = world.${lowerName}View;\n`;
        packerBody += `                const ptr = id * ${stride};\n`;
        for (const f of fields) {
            const leGet = f.bytes === 1 ? '' : ', true';
            const leSet = f.bytes === 1 ? '' : ', true';
            packerBody += `                view.${f.typeInfo.set}(offset, srcView.${f.typeInfo.view}(ptr + ${f.offset}${leGet})${leSet}); offset += ${f.bytes};\n`;
        }
        packerBody += `                return offset;\n`;
        packerBody += `            }\n`;

        // --- Build Unpacker ---
        unpackerBody += `            case ${config.id}: { // ${compName}\n`;
        unpackerBody += `                // Bounds check: need ${stride} bytes to read\n`;
        unpackerBody += `                if (view.byteLength < offset + ${stride}) return offset;\n`;
        unpackerBody += `                const dstView = world.${lowerName}View;\n`;
        unpackerBody += `                const ptr = id * ${stride};\n`;
        for (const f of fields) {
            const leGet = f.bytes === 1 ? '' : ', true';
            const leSet = f.bytes === 1 ? '' : ', true';
            unpackerBody += `                dstView.${f.typeInfo.set}(ptr + ${f.offset}, view.${f.typeInfo.view}(offset${leGet})${leSet}); offset += ${f.bytes};\n`;
        }
        unpackerBody += `                return offset;\n`;
        unpackerBody += `            }\n`;
    }

    // =========================================================================
    // 2. GENERATE WORLD STATE (Now that we have componentMeta)
    // =========================================================================
    let worldStateCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 * Source: packages/engine/scripts/schema.config.js
 */

import { EntityFlags } from './ComponentAccessors';

export const MAX_ENTITIES = 10000;

export interface IWorldBuffers {
    stateFlags?: ArrayBufferLike;
${componentMeta.map(m => `    ${m.name.toLowerCase()}?: ArrayBufferLike;`).join('\n')}
}

export interface IWorldConfig {
    maxEntities?: number;
    buffers?: IWorldBuffers;
}

export class WorldState {
    public readonly maxEntities: number;
    
    // Entity State Flags (ACTIVE, DEAD, etc.)
    public readonly stateFlags: Uint8Array;
    
    // Component Buffers
${componentMeta.map(m => {
        const n = m.name.toLowerCase();
        return `    public readonly ${n}: Float32Array;
    public readonly ${n}Buffer: ArrayBufferLike;
    public readonly ${n}View: DataView;`;
    }).join('\n')}

    // EIDOLON-V: Sparse Set for O(1) Iteration
    public readonly activeEntities: Uint16Array; // Dense [id1, id2, ...]
    public readonly entityToIndex: Int16Array;   // Sparse [id] -> index
    public activeCount: number = 0;

    constructor(config?: IWorldConfig) {
        this.maxEntities = config?.maxEntities ?? MAX_ENTITIES;
        
        // Allocate State Flags (1 byte per entity)
        if (config?.buffers?.stateFlags) {
            this.stateFlags = new Uint8Array(config.buffers.stateFlags);
        } else {
            this.stateFlags = new Uint8Array(this.maxEntities);
        }
        
        // Allocate Component Buffers
`;

    for (const meta of componentMeta) {
        const lowerName = meta.name.toLowerCase();
        worldStateCode += `        if (config?.buffers?.${lowerName}) {\n`;
        worldStateCode += `            this.${lowerName}Buffer = config.buffers.${lowerName};\n`;
        worldStateCode += `        } else {\n`;
        worldStateCode += `            this.${lowerName}Buffer = new ArrayBuffer(this.maxEntities * ${meta.stride});\n`;
        worldStateCode += `        }\n`;
        worldStateCode += `        this.${lowerName} = new Float32Array(this.${lowerName}Buffer);\n`;
        worldStateCode += `        this.${lowerName}View = new DataView(this.${lowerName}Buffer);\n`;
    }

    // Add Sparse Set initialization
    worldStateCode += `\n        // EIDOLON-V: Initialize Sparse Set\n`;
    worldStateCode += `        this.activeEntities = new Uint16Array(this.maxEntities);\n`;
    worldStateCode += `        this.entityToIndex = new Int16Array(this.maxEntities).fill(-1);\n`;

    worldStateCode += `    }

    /**
     * Reset all component data to zero
     */
    reset(): void {
        this.stateFlags.fill(0);
`;
    for (const meta of componentMeta) {
        worldStateCode += `        this.${meta.name.toLowerCase()}.fill(0);\n`;
    }
    worldStateCode += `
        // EIDOLON-V: Reset Sparse Set
        this.activeCount = 0;
        this.activeEntities.fill(0);
        this.entityToIndex.fill(-1);
    }

    /**
     * Check if entity ID is valid AND ACTIVE
     * P3-2 FIX: Also checks ACTIVE flag to prevent reading stale data
     */
    isValidEntityId(id: number): boolean {
        return id >= 0 && id < this.maxEntities &&
            (this.stateFlags[id] & EntityFlags.ACTIVE) !== 0;
    }
}

// STRIDES in floats (for array indexing, not bytes)
export const STRIDES = {
`;
    for (const meta of componentMeta) {
        const strideFloats = meta.stride / 4;
        worldStateCode += `    ${meta.name.toUpperCase()}: ${strideFloats},\n`;
    }
    worldStateCode += `} as const;

/**
 * Default global WorldState instance.
 * Used for backward compatibility with static Store classes.
 * @deprecated Prefer injecting WorldState instances for new code.
 */
export const defaultWorld = new WorldState();

// EIDOLON-V P6: Runtime deprecation warning
declare const __DEV__: boolean | undefined;
if (typeof console !== 'undefined' && typeof __DEV__ !== 'undefined' && __DEV__) {
  console.warn('[EIDOLON-V] defaultWorld singleton is deprecated. Use new WorldState() for instance-based architecture.');
}
`;

    // =========================================================================
    // 3. FINALIZE OTHER FILES
    // =========================================================================
    packerCode += `} as const;
    
export const COMPONENT_STRIDES = {
`;
    for (const meta of componentMeta) {
        packerCode += `    ${meta.name.toUpperCase()}: ${meta.stride},\n`;
    }
    packerCode += `} as const;
`;
    packerCode += packerBody;
    packerCode += `            default: return offset;\n        }\n    }\n}\n`;

    deserializerCode += unpackerBody;
    deserializerCode += `            default: return offset;\n        }\n    }\n}\n`;

    // =========================================================================
    // 4. WRITE FILES
    // =========================================================================
    fs.writeFileSync(path.join(OUTPUT_DIR, 'WorldState.ts'), worldStateCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'ComponentAccessors.ts'), accessorCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'NetworkPacker.ts'), packerCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'NetworkDeserializer.ts'), deserializerCode);

    // Generate index.ts
    const indexCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS
 * Generated: ${timestamp}
 */

export { WorldState, MAX_ENTITIES, STRIDES, defaultWorld, type IWorldConfig, type IWorldBuffers } from './WorldState';
export * from './ComponentAccessors';
export { NetworkSerializer, COMPONENT_IDS, COMPONENT_STRIDES } from './NetworkPacker';
export { NetworkDeserializer } from './NetworkDeserializer';
`;
    fs.writeFileSync(path.join(OUTPUT_DIR, 'index.ts'), indexCode);

    console.log('âœ… Generated WorldState.ts');
    console.log('âœ… Generated ComponentAccessors.ts');
    console.log('âœ… Generated NetworkPacker.ts');
    console.log('âœ… Generated NetworkDeserializer.ts');
    console.log('âœ… Generated index.ts');
    console.log(`ðŸ“ Output: ${OUTPUT_DIR}`);
    console.log('ðŸš€ EIDOLON SYSTEM READY.');
}

generate();
