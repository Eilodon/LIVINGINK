/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Network Serialization - Packet matches Memory Layout exactly
 * Generated: 2026-02-08T15:29:30.437Z
 */

import type { WorldState } from './WorldState';

export const COMPONENT_IDS = {
    TRANSFORM: 1,
    PHYSICS: 2,
    PIGMENT: 3,
    STATS: 4,
    INPUT: 5,
    SKILL: 6,
    CONFIG: 7,
    PROJECTILE: 8,
    TATTOO: 9,
} as const;
    
export const COMPONENT_STRIDES = {
    TRANSFORM: 32,
    PHYSICS: 32,
    PIGMENT: 32,
    STATS: 32,
    INPUT: 16,
    SKILL: 16,
    CONFIG: 32,
    PROJECTILE: 16,
    TATTOO: 20,
} as const;

export class NetworkSerializer {
    /**
     * Pack a single entity's component into a DataView
     * @returns New offset after writing
     */
    static packEntityComponent(
        world: WorldState, 
        id: number, 
        componentId: number, 
        view: DataView, 
        offset: number
    ): number {
        // EIDOLON-V P1: Defense-in-depth bounds check
        if (id < 0 || id >= world.maxEntities) return offset;
        
        switch (componentId) {
            case 1: { // Transform
                // Bounds check: need 32 bytes to write
                if (view.byteLength < offset + 32) return offset;
                const srcView = world.transformView;
                const ptr = id * 32;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 20, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 24, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 28, true), true); offset += 4;
                return offset;
            }
            case 2: { // Physics
                // Bounds check: need 32 bytes to write
                if (view.byteLength < offset + 32) return offset;
                const srcView = world.physicsView;
                const ptr = id * 32;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 20, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 24, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 28, true), true); offset += 4;
                return offset;
            }
            case 3: { // Pigment
                // Bounds check: need 32 bytes to write
                if (view.byteLength < offset + 32) return offset;
                const srcView = world.pigmentView;
                const ptr = id * 32;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 20, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 24, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 28, true), true); offset += 4;
                return offset;
            }
            case 4: { // Stats
                // Bounds check: need 32 bytes to write
                if (view.byteLength < offset + 32) return offset;
                const srcView = world.statsView;
                const ptr = id * 32;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 20, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 24, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 28, true), true); offset += 4;
                return offset;
            }
            case 5: { // Input
                // Bounds check: need 16 bytes to write
                if (view.byteLength < offset + 16) return offset;
                const srcView = world.inputView;
                const ptr = id * 16;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setUint32(offset, srcView.getUint32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                return offset;
            }
            case 6: { // Skill
                // Bounds check: need 16 bytes to write
                if (view.byteLength < offset + 16) return offset;
                const srcView = world.skillView;
                const ptr = id * 16;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                return offset;
            }
            case 7: { // Config
                // Bounds check: need 32 bytes to write
                if (view.byteLength < offset + 32) return offset;
                const srcView = world.configView;
                const ptr = id * 32;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 20, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 24, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 28, true), true); offset += 4;
                return offset;
            }
            case 8: { // Projectile
                // Bounds check: need 16 bytes to write
                if (view.byteLength < offset + 16) return offset;
                const srcView = world.projectileView;
                const ptr = id * 16;
                view.setFloat32(offset, srcView.getFloat32(ptr + 0, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                return offset;
            }
            case 9: { // Tattoo
                // Bounds check: need 20 bytes to write
                if (view.byteLength < offset + 20) return offset;
                const srcView = world.tattooView;
                const ptr = id * 20;
                view.setUint8(offset, srcView.getUint8(ptr + 0)); offset += 1;
                view.setUint8(offset, srcView.getUint8(ptr + 1)); offset += 1;
                view.setUint8(offset, srcView.getUint8(ptr + 2)); offset += 1;
                view.setUint8(offset, srcView.getUint8(ptr + 3)); offset += 1;
                view.setFloat32(offset, srcView.getFloat32(ptr + 4, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 8, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 12, true), true); offset += 4;
                view.setFloat32(offset, srcView.getFloat32(ptr + 16, true), true); offset += 4;
                return offset;
            }
            default: return offset;
        }
    }
}
